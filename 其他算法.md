## 其他算法

### 二分

```cpp
/*求答案在右半段的二分*/
while(l<r){
	int mid=l+r>>1;
	if(check(mid)) r=mid;
	else l=mid+1;
}

/*求答案在左半段的二分*/
while(l<r){
	int mid=l+r>>1;
	if(check(mid)) l=mid;
	else r=mid-1;
}
```

### ST表

```cpp
int st[N][M];
int logn[N];
int n,m;
int w[N];

void init(){
    for(int i=2;i<=n;i++) logn[i]=logn[i/2]+1;

    for(int j=0;j<M;j++) for(int i=1;i+(1<<j)-1<=n;i++)
        if(!j) st[i][j]=w[i];
        else st[i][j]=max(st[i][j-1],st[i+(1<<j-1)][j-1]);
}

int query(int l,int r){
    int len=r-l+1;
    int k=logn[len];
    return max(st[l][k],st[r-(1<<k)+1][k]); 
}
```

### 启发式合并

例题：梦幻布丁

一天，小徐的好友邀请他去吃布丁，于是小徐高高兴兴的来到好友家。

哇，这么多五彩缤纷的布丁！

好友说：“在我们开吃前先玩会儿游戏吧。”

于是他将布丁摆成一行，接着说：“我可以把某种颜色的布丁全部变成另一种颜色，我还会在某些时刻问你当前一共有多少段颜色。例如：颜色分别为 $1,2,2,1$ 的四个布丁一共有 $3$ 段颜色。”

#### 输入格式

第一行包含整数 $n$ 和 $m$，分别表示布丁的个数和好友的操作次数。

第二行包含 $n$ 个空格隔开的整数 $A1,A2,…,An$，其中 $A_i$表示第 $i$ 个布丁的颜色。

从第三行起的 $m$ 行，依次描述 $m$ 个操作。

对每个操作，若第一个数是 $1$，则表示好友要改变颜色，这时后跟两个整数 $x$ 和 $y$（可能相等），表示执行该操作后所有颜色为 $x$ 的布丁被变成颜色 $y$。

若第一个数是 $2$，则表示好友要询问目前有多少段颜色，这时应该输出一个整数回答。

#### 输出格式

对于每个询问，在一行中输出一个整数作为回答。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+50, M=1e6+50;

int col[N], n, q;

struct node{
    int to, next;
}e[N];
int h[M], tot;
int sz[M], p[M];
int cur;

void add(int u, int v){
    e[tot].to=v, e[tot].next=h[u], h[u]=tot++;
}

void merge(int &x, int &y){
    if(x==y) return; // spj
    if(sz[x]>sz[y]) swap(x, y);

    // begin merge group x to y
    // need to update the info: cur, sz[], col[], h[]
    for(int i=h[x]; ~i; i=e[i].next){ // update the cur
        int go=e[i].to;
        cur-=(col[go-1]==y)+(col[go+1]==y);
    }

    for(int i=h[x]; ~i; i=e[i].next){
        int go=e[i].to;
        col[go]=y;
        if(e[i].next==-1){ // in the end
            e[i].next=h[y], h[y]=h[x], h[x]=-1;
            break;
        }
    }

    sz[y]+=sz[x], sz[x]=0;
}
int main(){
    memset(h, -1, sizeof h);
    cin>>n>>q;

    for(int i=1; i<=n; i++){
        cin>>col[i]; sz[col[i]]++;
        add(col[i], i);
    }

    for(int i=1; i<M; i++) p[i]=i;
    for(int i=1; i<=n; i++) if(col[i]!=col[i-1]) cur++;

    while(q--){
        int op; cin>>op;
        if(op==1){ 
            int x, y; cin>>x>>y;
            merge(p[x], p[y]);
        }else cout<<cur<<endl;
    }

    return 0;
}
```

